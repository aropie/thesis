\section{Workflow}
\subsection{¿Qué se hizo?}
Se tomó una base de datos cristalográfica de acoplamientos ya
realizados y sobre esos ligandos y proteinas se corrió Docking con
AutoDockVina n.m. Después se hace una tabla comparando los scores que
les asigna AutoDockVina con el RMSDI cristalográfico. Pero los scores
de autodockvina no siempre son muy buenos y pasa que muchas veces la
que es la mejor pose la manda al $4^o$ o $5^o$ lugar del ranking.
Aquí es donde entra la red:

Pereira, Caffaren y dos Santos \cite{dossantos} consideran al átomo
como una entidad ligada íntimamente con su contexto. Con esta premisa,
crean una red que toma como entrada a cada átomo del ligando con su
contexto codificado, entendiendo contexto del átomo como las
carácteristicas de este y de los átomos más cercanos.
Pereira buscaba encontrar el acoplamiento que generara la mayor
cantidad de energía, sin importar cual fuera la conformación necesaria
para poder realizarlo; nuestro enfoque busca precisamente encontrar
dicha conformación.

\subsubsection{Contexto de la rama}
Partiendo de la ídea del átomo ligado a su contexto, y considerando
que lo que buscamos encontrar es una propiedad puramente estructural,
tomamos como unidad básica del ligando a la rama. Así, nuestro
\textit{contexto de átomo} se convierte en \textbf{contexto de rama},
siendo este la combinación de el tipo de rama, los de las ramas más
cercanas y la distancia a cada una de ellas.

A partir de ese diccionario (con su respectivo índice), se asocia a
una rama con las cinco ramas más cercanas codificadas a través de sus
tipos y sus distancias a las ramas dadas. Esto se hace para cada rama
del ligando.

Para el tipo de rama se divide cada ligando en sus respectivas ramas y
cada una de estas ramas se codifica usando la respresentación
SMILES \footnote{\url{http://www.daylight.com/smiles/}} y se ponen en
un listado donde se asocia cada rama codificada con un índice,
generando así lo que llamamos el \textit{diccionario de ramas}.

Luego, una capa convolucionall es empleada para sintetizar la
información de todos los contextos de todas las ramas del ligando y
genera una representación vectorial del complejo. Después se pasa a
\sout{dos} capas ocultas para sintetización y procesamiento del
vector-ligando. Finalmente, en la última capa, la representación del
complejo es dada como entrada a un clasificador \textit{softmax},
quien es responsable de producir el puntaje. A continuación se
presenta un pseudo-código de alto nivel del proceso de la red:
\begin{algorithm}
  \caption{Red con nombre fancy}
  \begin{algorithmic}[1]
    \State \textbf{Dados:}\newline
                           $W_{b\_type} \in \mathbb{R}^{h\times |B|}, W_{b\_dist}
                           \in \mathbb{R}^{h\times |B|},\newline
                           W_{conv} \in \mathbb{R}^{|z_i| \times cf}, W_1 \in
                           \mathbb{R}^{cf \times h_1},\newline
                           W_2 \in \mathbb{R}^{h_1 \times h_2}, W_{out} \in
                           \mathbb{R}^{h_2 \times out},\newline
                           b_{conv} \in \mathbb{R}^{cf}, b_{1} \in
                           \mathbb{R}^{h_1},\newline
                           b_{2} \in \mathbb{R}^{h_2}, b_{out}
                           \in \mathbb{R}^{out}$
    \State $Z = []$
    \For{$i=1$ to $m$}
      \State $z_{b\_type}$ = columnas de $W_{b\_type}$
      correspondientes a los tipos de ramas de los vecinos de la
      rama $i$
      \State $z_{b\_dist}$ = columnas de $W_{b\_dist}$
      correspondientes a las distancias de los vecinos de la rama $i$
      \State $z_i$ = {$z_{b\_type}, z_{b\_dist}$}
      \State $Z.add(z_i)$
    \EndFor
    \State // $U$ es inicializada con ceros
    \State $U = [..] \in \mathbb{R}^{cf \times m}$
    \State // Capa convolucional
    \For{$i=1 to m$}
      \State $U[:,i]=f(W_1Z[i] + b_1)$
    \EndFor
    \State // max-pooling por columnas
    \State $r=max(U, axis=1)$
    \State //Capas ocultas y capa de salida
    \State $score=W_3(W_2r + b_2) + b_3$
    \State // Regresa el puntaje normalizado
    \State \textbf{return} $\frac{e^{score[1]}}{e^{score[0]}+e^{score[1]}}$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Euclid’s algorithm}\label{euclid}
\begin{algorithmic}[1]
\Procedure{Euclid}{$a,b$}\Comment{The g.c.d. of a and b}
\State $r\gets a\bmod b$
\While{$r\not=0$}\Comment{We have the answer if r is 0}
\State $a\gets b$
\State $b\gets r$
\State $r\gets a\bmod b$
\EndWhile\label{euclidendwhile}
\State \textbf{return} $b$\Comment{The gcd is b}
\EndProcedure
\end{algorithmic}
\end{algorithm}
