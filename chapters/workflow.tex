\section{Workflow}
Se tomó una base de datos cristalográfica de acoplamientos ya
realizados y sobre esos ligandos y proteinas se corrió Docking con
AutoDockVina n.m. Después se hace una tabla comparando los scores que
les asigna AutoDockVina con el RMSDI cristalográfico. Pero los scores
de autodockvina no siempre son muy buenos y pasa que muchas veces la
que es la mejor pose la manda al $4^o$ o $5^o$ lugar del ranking.

\subsection{Contexto de la rama}
Pereira, Caffaren y dos Santos \cite{dossantos} consideran al átomo
como una entidad ligada íntimamente a su contexto. Bajo esta premisa,
crean una red que toma como entrada a cada átomo del ligando con su
contexto codificado, entendiendo contexto del átomo como las
carácteristicas de este y de los átomos más cercanos.
Pereira buscaba encontrar el acoplamiento que generara la mayor
cantidad de energía, sin importar cual fuera la conformación necesaria
para poder realizarlo; nuestro enfoque busca precisamente encontrar
dicha conformación.

Partiendo de la ídea del átomo ligado a su contexto, y considerando
que lo que buscamos encontrar es una propiedad puramente estructural,
tomamos como unidad básica del ligando a los segmentos con libertad
rotacional, al que llamaremos \textit{rama}. Así, nuestro
\textit{contexto de átomo} se convierte en \textbf{contexto de rama},
siendo este la combinación de el tipo de rama, los de las ramas más
cercanas y la distancia a cada una de ellas.

IMAGEN HISTOGRAMA DE DISTRIBUCIÖN DE TIPOS DE RAMA

Se divide cada receptor y ligando en sus respectivas ramas y cada una
de estas ramas se codifica usando la respresentación
SMILES \footnote{\url{http://www.daylight.com/smiles/}}. Esta
codificación, representa de forma única a cada rama distinta; es a
esto a lo que llamamos \textbf{tipo de rama}. Se enlistan todos los
tipos de rama, asociando a cada uno un índice, generando así lo que
llamamos el \textit{diccionario de ramas}.

Del mismo modo, se segmentan los rangos de distancia encontrados en
compartimentos, y a cada uno de estos se les asigna también un índice,
generando así un \textit{diccionario de distancias}.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{l|l}
      SMILES                 & Id \\ \hline
      NC1=N{[}C{]}(=NC=C1)=O & 93 \\
      C1CCCCC1               & 94 \\
      CNC=O                  & 95 \\
      NC=N                   & 96 \\
      CC=C                   & 97
    \end{tabular}
    \begin{tabular}{l|l}
      Rango de distancia (\AA) & Idx \\ \hline
      3.0526 - 3.2631        & 6   \\
      3.2632 - 3.4736        & 7   \\
      3.4737 - 3.6842        & 8   \\
      3.6843 - 3.8947        & 9   \\
      3.8948 - 4.1052        & 10
    \end{tabular}
  \end{center}
  \caption{Fragmento de los diccionarios de ramas y de distancias}
  \label{fig:dictionary}
\end{table}

A partir de estos diccionarios, se asocia a una rama del ligando con
las cinco ramas del receptor más cercanas codificadas a través de sus
tipos y sus distancias a las ramas dadas, generando así el
\textit{vector de la rama}.

\begin{table}[H]
  \begin{center}
  \begin{tabular}{l|l}
    OP(O)O                 & \AA        \\ \hline
    N                      & 5.794664 \\
    C1CC1                  & 5.691862 \\
    NC1=N{[}C{]}(=NC=C1)=O & 4.449922 \\
    NC=N                   & 3.785496 \\
    O                      & 3.747894
  \end{tabular}
  \end{center}
  \begin{equation*}
  \downarrow
  \end{equation*}
  \begin{equation*}
    OP(O)O=\begin{bmatrix}
    (2, 13, 93, 96, 4) & (4, 2, 2, 6, 4)
    \end{bmatrix}
  \end{equation*}
  \caption{Traducción de una rama a su representación vectorial}
\end{table}

Luego, una capa convolucional es empleada para sintetizar la
información de todos los contextos de todas las ramas del ligando y
genera una representación vectorial del complejo. Después se pasa a
dos capas ocultas para sintetización y procesamiento del
vector-ligando. Finalmente, en la última capa, la representación del
complejo es dada como entrada a un clasificador \textit{softmax},
quien es responsable de producir el puntaje. A continuación se
presenta un pseudo-código de alto nivel del proceso de la red:
\begin{algorithm}
  \caption{Deep-pose}
  \begin{algorithmic}[1]
    \State \textbf{Dados:}\newline
                           $W_{b\_type} \in \mathbb{R}^{h\times |B|}, W_{b\_dist}
                           \in \mathbb{R}^{h\times |B|},\newline
                           W_{conv} \in \mathbb{R}^{|z_i| \times cf}, W_1 \in
                           \mathbb{R}^{cf \times h_1},\newline
                           W_2 \in \mathbb{R}^{h_1 \times h_2}, W_{out} \in
                           \mathbb{R}^{h_2 \times out},\newline
                           b_{conv} \in \mathbb{R}^{cf}, b_{1} \in
                           \mathbb{R}^{h_1},\newline
                           b_{2} \in \mathbb{R}^{h_2}, b_{out}
                           \in \mathbb{R}^{out}$
    \State $Z = []$
    \For{$i=1$ to $m$}
      \State $z_{b\_type}$ = columnas de $W_{b\_type}$
      correspondientes a los tipos de ramas de los vecinos de la
      rama $i$
      \State $z_{b\_dist}$ = columnas de $W_{b\_dist}$
      correspondientes a las distancias de los vecinos de la rama $i$
      \State $z_i$ = {$z_{b\_type}, z_{b\_dist}$}
      \State $Z.add(z_i)$
    \EndFor
    \State // $U$ es inicializada con ceros
    \State $U = [..] \in \mathbb{R}^{cf \times m}$
    \State // Capa convolucional
    \For{$i=1 to m$}
      \State $U[:,i]=f(W_1Z[i] + b_1)$
    \EndFor
    \State // max-pooling por columnas
    \State $r=max(U, axis=1)$
    \State //Capas ocultas y capa de salida
    \State $score=W_3(W_2r + b_2) + b_3$
    \State // Regresa el puntaje normalizado
    \State \textbf{return} $\frac{e^{score[1]}}{e^{score[0]}+e^{score[1]}}$
  \end{algorithmic}
\end{algorithm}
